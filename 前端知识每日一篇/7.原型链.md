### 原型链

* 创建对象有几种方法？
    * 字面量
    ```
        var obj = {name:'jack'}
        var obj2 = new Object({name: 'tom'})
    ```    

    * 通过构造函数
    ```
        var M = function(name) {
            this.name = name;
        }

        var obj = new M("jack");
    ```    

    * Object.create()----创建一个对象，其原型（obj2.[__proto__]）指向参数对象obj
    ```
        var obj = {name: 'jack'};
        var obj2 = Object.create(obj);
    ```    

* 原型、构造函数、实例、原型链
    * 构造函数中的方法，每个实例对象的方法都不一样
    * 浪费内存，多个实例无法共享构造函数中的方法
    * 把构造函数中共同的方法，放到构造函数的原型对象中
    * 实例对象在查找属性时，会主动去查找构造函数的原型对象
    * 实现了多个实例对象共享同一个方法
    * 减少了内存的浪费。

    * 以上就是**为什么会有原型链**。
    * 是因为构造函数中的方法，导致多个实例对象，产生**重复的数据**。


    * 构造函数---原型对象---实例对象的三角形关系图
    * 原型链：实例对象查找属性时，会沿着原型链去查找。

    * 函数也是对象

* instanceof的原理（重点）
    * 在同一条原型链上的所有的构造函数，都是某个实例对象的构造函数 
    * 如何判断实例对象到底由哪个构造函数创建
    * **使用obj.[__proto__].constructor 来判断实例对象的构造函数比 instanceof更准确**

* new 运算符
    * new 构造函数 
    * 一个新对象被创建。它继承自 构造函数.prototype
    * 构造函数被执行。执行的时候， this 会被指定为这个新实例。
    * 返回new出来的对象。
    